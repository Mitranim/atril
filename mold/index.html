<!DOCTYPE html>
<html>
  <head>
    <title>atril</title>
    <meta name="author" content="Mitranim">
    <meta name="description" content="Experimental JS rendering library. Ideas from ReactJS, Polymer, Angular 2, Aurelia, made simple.">
    <meta charset="utf-8">
    <link rel="icon" href="data:;base64,=">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">
    <base href="/atril/">
    <link rel="stylesheet" type="text/css" href="/atril/css/app.css">

    <!-- Block rendering while preparing the document -->
    
      <script src="build.js"></script>
    
  </head>

  <body>
    <div class="doc-banner">
  <h1 class="text-monospace size-initial">atril</h1>

  <h3>Experimental JS rendering library</h3>

  <p style="font-size: 1rem">Ideas from ReactJS, Polymer, Angular 2, Aurelia, made simple</p>

  <div class="link-section">
    <a href="https://github.com/Mitranim/atril" target="_blank">
      <sf-icon class="github-light pop"></sf-icon>
    </a>
    <a href="http://mitranim.com/#contacts" target="_blank">
      <sf-icon class="external-link pop" style="font-size: 0.8em"></sf-icon>
    </a>
    <!-- https://github.com/Mitranim/atril&text=Star&data.style=mega&data.icon=octicon-star&aria.label=Star -->
    <iframe allowtransparency="true" scrolling="no" frameborder="0" style="border: none" src="https://buttons.github.io/buttons.html#href%3Dhttps%3A%2F%2Fgithub.com%2FMitranim%2Fatril%26text%3DStar%26data.style%3Dmega%26data.icon%3Docticon-star%26aria.label%3DStar"></iframe>
  </div>
</div>

    <div class="flex" style="width: 100%; margin-top: 2rem">
      <div class="flex-5 order-1 space-out-v" style="padding: 0 1rem">
        <h2><span>Mold</span><a class="heading-anchor" autolink.="mold"><sf-icon class="inline link"></sf-icon></a></h2>
<div class="info pad decorate-links">
  <p>Quicklinks</p>
  <ul>
    <li><a href="mold/#basics">Basics</a></li>
    <li><a href="mold/#mutation">Mutation</a></li>
    <li><a href="mold/#optimisation">Optimisation</a></li>
    <li><a href="mold/#contextual-dependencies">Contextual Dependencies</a></li>
    <li><a href="mold/#lifecycle">Lifecycle</a></li>
  </ul>
</div>

<p>Molds let you modulate the structure of the virtual DOM. They fill the  role
between custom elements that can only <em>define</em> the view, and custom attributes
that can only modify <em>existing</em> DOM nodes.</p>
<p>A mold is a combination of a <code>template</code> tag with a custom attribute. It can be
used as a <code>template</code> (enclosing some content). As a shortcut, you can also use
it as an attribute on a normal element; in this case it&#39;s automatically expanded
into a <code>template</code>.</p>
<p>In essense, a mold has &quot;admin access&quot; to the part of the virtual DOM enclosed by
it. Example of a mold in practice:</p>
<pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">twoway.checked</span>=<span class="hljs-value">"checked"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"checkbox"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Conditional rendering --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">if.</span>=<span class="hljs-value">"checked"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>I'm included into the DOM conditionally.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<template doc-demo.>
<div>
  <label>
    <input twoway.checked="checked" type="checkbox">
    <span>Toggle</span>
  </label>
</div>
<template if.="checked">
  <p>I&#39;m included into the DOM conditionally.</p>
</template>
</template>

<p>The mold (in this case, the controller of the <a href="if/"><code>if.</code></a> attribute) decides
what to with the content caught inside the template tag (in this case, the
<code>&lt;p&gt;</code>). It could ignore the content, clone and multiply it, or replace it with
something else entirely.</p>
<p>In this case, the <code>if.</code> attribute simply includes the content when the condition
is met, and removes it when not.</p>
<h3><span>Basics</span><a class="heading-anchor" autolink.="basics"><sf-icon class="inline link"></sf-icon></a></h3>
<p>First, let&#39;s understand the
HTML5 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" target="_blank"><code>template</code> element</a>.
When HMTL is parsed into the virtual DOM, the contents of each <code>template</code> tag
are put into the special property <code>content</code>. <code>atril</code> shims this behaviour in
non-supporting browsers when compiling the DOM.</p>
<p>The mold controller (the class decorated with <code>@Mold</code>) has access to its virtual
<code>template</code> element. During its <code>constructor</code> call or in the lifecycle method
<code>onPhase</code> it has a chance to take the mold&#39;s initial content, perform arbitrary
transformations, and append the result to the template element itself. The
mold&#39;s &quot;output&quot; is the resulting <code>childNodes</code> of the template element.</p>
<p>When a mold is constructed, and every time it&#39;s phased, the library checks the
template&#39;s contents to see if they need to be recompiled. Any custom elements,
custom attributes, or molds in the output are automatically activated. Then the
contents are synced to the real DOM. The template element itself is not included
into the DOM.</p>
<p>Let&#39;s implement a mold that compiles and outputs markdown. Using the demo
project from <a href="quickstart/">Quickstart</a>, create a file <code>src/app/molds/to-
markdown.ts</code> with the following.</p>
 <sf-collapse class="info">
  <input id="static-id-1" type="checkbox">
  <label for="static-id-1" class="pad">
    <sf-icon svg-icon.="question-circle" class="inline text-info"></sf-icon>
    Expand code.
  </label> 
<pre><code class="hljs lang-typescript"><span class="hljs-keyword">import</span> {Mold, assign} from <span class="hljs-string">'atril'</span>;
<span class="hljs-keyword">import</span> marked from <span class="hljs-string">'marked'</span>;

@Mold({
  attributeName: <span class="hljs-string">'markdown-live'</span>
})
<span class="hljs-keyword">class</span> Ctrl {
  @assign element: HTMLTemplateElement;
  @assign expression: <span class="hljs-built_in">Function</span>;
  @assign scope: <span class="hljs-built_in">any</span>;

  buffer: HTMLElement;
  lastValue: <span class="hljs-built_in">string</span>;

  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>() </span>{
    <span class="hljs-keyword">this</span>.buffer = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">this</span>.rewrite();
  }

  onPhase() {
    <span class="hljs-keyword">this</span>.rewrite();
  }

  rewrite() {
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>.expression(<span class="hljs-keyword">this</span>.scope) || <span class="hljs-string">''</span> + <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (value === <span class="hljs-keyword">this</span>.lastValue) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.buffer.innerHTML = marked(value);

    <span class="hljs-comment">// Remove existing content.</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.element.hasChildNodes()) {
      <span class="hljs-keyword">this</span>.element.removeChild(<span class="hljs-keyword">this</span>.element.firstChild);
    }

    <span class="hljs-comment">// Add new content.</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.buffer.hasChildNodes()) {
      <span class="hljs-keyword">this</span>.element.appendChild(<span class="hljs-keyword">this</span>.buffer.removeChild(<span class="hljs-keyword">this</span>.buffer.firstChild));
    }

    <span class="hljs-keyword">this</span>.lastValue = value;
  }
}
</code></pre>
 </sf-collapse> 
<p>Then use it in your view like so:</p>
<pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">textarea</span> <span class="hljs-attribute">twoway.value</span>=<span class="hljs-value">"myContent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">textarea</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">markdown-live.</span>=<span class="hljs-value">"myContent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<template doc-demo.>
  <div class="flex space-out-h">
<textarea twoway.value="value" class="flex-1 text-monospace">
## Mold

Molds let you modulate the structure of the virtual DOM. They fill the role between custom elements that can only _define_ the view, and custom attributes that can only modify _existing_ DOM nodes.

In essense, a mold gives you "admin access" to the part of the virtual DOM enclosed by it. Example:

```html
<template if.="true">
  <p>I'm included into the DOM conditionally.</p>
</template>
```
</textarea>
    <sf-article class="flex-1">
      <template markdown-live.="value"></template>
    </sf-article>
  </div>
</template>

<p>Why go through all this fiddly DOM manipulation? Wouldn&#39;t it be easier to just
keep one element in the DOM and replace its <code>innerHTML</code> with the compiled
results?</p>
<p>For plain markdown, it would be. However, there&#39;s more to it:</p>
<ul>
<li>A mold may have any number of children, including zero, and its output is
automatically included into the correct place in the DOM.</li>
<li>The mold output is not inert HTML. It&#39;s automatically compiled and activated.</li>
</ul>
<p>Let&#39;s see what happens if our markdown contains <code>atril</code> markup.</p>
<template doc-demo.>
  <div class="flex space-out-h">
<textarea twoway.value="value" class="flex-1 text-monospace" rows="8">
<label>
  <input twoway.value="text"
         placeholder="write something...">
</label>

{{text}}
</textarea>
    <sf-article class="flex-1">
      <template markdown-live.="value"></template>
    </sf-article>
  </div>
</template>

<p>The contents of the <code>template</code> tag were automatically compiled by the library
and activated just like a normal part of the view.</p>
<h3><span>Mutation</span><a class="heading-anchor" autolink.="mutation"><sf-icon class="inline link"></sf-icon></a></h3>
<p>More often you want to use a mold to modify <em>existing</em> virtual markup. In the
previous example, we used a separate input to generate the markdown. Now let&#39;s
put it directly into the template.</p>
<p>Here&#39;s the implementation:</p>
 <sf-collapse class="info">
  <input id="static-id-2" type="checkbox">
  <label for="static-id-2" class="pad">
    <sf-icon svg-icon.="question-circle" class="inline text-info"></sf-icon>
    Expand code.
  </label> 
<pre><code class="hljs lang-typescript"><span class="hljs-keyword">import</span> {Mold, assign} from <span class="hljs-string">'atril'</span>;
<span class="hljs-keyword">import</span> marked from <span class="hljs-string">'marked'</span>;

@Mold({
  attributeName: <span class="hljs-string">'markdown'</span>
})
<span class="hljs-keyword">class</span> Ctrl {
  @assign element: HTMLTemplateElement;

  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>() </span>{
    <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">this</span>.element.content;

    <span class="hljs-comment">// Convert existing content into text.</span>
    <span class="hljs-keyword">let</span> buffer = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">while</span> (content.hasChildNodes()) {
      buffer.appendChild(content.firstChild);
    }

    <span class="hljs-comment">// Render into markdown.</span>
    <span class="hljs-keyword">let</span> result = marked(buffer.innerHTML);
    buffer.innerHTML = result;

    <span class="hljs-keyword">while</span> (buffer.hasChildNodes()) {
      <span class="hljs-keyword">this</span>.element.appendChild(buffer.removeChild(buffer.firstChild));
    }
  }
}
</code></pre>
 </sf-collapse> 
<p>Use it in HTML like so:</p>
<pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">markdown.</span>&gt;</span>
## Header

* list item
* list item
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<p>The mold automatically converts its content into markdown, and here&#39;s the result:</p>
<template doc-demo.>
 <template markdown.>
## Header

* list item
* list item
</template> 
</template>

<h3><span>Optimisation</span><a class="heading-anchor" autolink.="optimisation"><sf-icon class="inline link"></sf-icon></a></h3>
<p>By default, the library automatically recompiles the mold&#39;s output (the
contents of the <code>template</code> tag). If you create new parts of the virtual DOM
that use <code>atril</code> features like custom elements, they will work automatically.</p>
<p>However, this has a performance cost. Because the library doesn&#39;t know which
parts of the virtual DOM you could have modified, it has to scan the entire
subtree. If your mold reuses some parts of its virtual DOM, leaving them
unchanged between phases, you can &quot;hint&quot; the library not to rescan them.</p>
<p>Excerpt from the <code>if.</code> implementation:</p>
<pre><code class="hljs lang-typescript">@Mold({attributeName: <span class="hljs-string">'if'</span>})
<span class="hljs-keyword">class</span> If {
  <span class="hljs-comment">/* ... */</span>

  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>() </span>{
      <span class="hljs-comment">/* ... */</span>
      Meta.getOrAddMeta(child).isDomImmutable = <span class="hljs-literal">true</span>;
      <span class="hljs-comment">/* ... */</span>
  }
}
</code></pre>
<p>The <code>Meta</code> object is a metadata container associated with each node in the
virtual DOM tree. The library adds them automatically when compiling nodes,
but you can also add a meta to a newly created node.</p>
<p>If a node is marked as <code>isDomImmutable</code> in its metadata, the library will
only compile it once, and skip on subsequent reflows. &quot;Immutability&quot; refers
to the inner DOM structure of that virtual element, and doesn&#39;t prevent DOM
updates like text interpolations.</p>
<p>By hinting which mold children won&#39;t change, you conserve a considerable amount
of performance.</p>
<h3><span>Contextual Dependencies</span><a class="heading-anchor" autolink.="contextual-dependencies"><sf-icon class="inline link"></sf-icon></a></h3>
<p>The library uses a variant of dependency injection — <em>dependency assignment</em> —
to give you contextual dependencies for each mold controller. To get hold of
them, use the <code>@assign</code> decorator (ES7/TypeScript) or the static <code>assign</code>
property on the constructor function (ES5).</p>
<p>A mold has the following contextual dependencies:</p>
<ul>
<li><code>element</code> — the virtual <code>template</code> element;</li>
<li><code>attribute</code> — the associated
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Attr" target="_blank"><code>Attr</code></a> object on the
template element;</li>
<li><code>hint</code> — the part in the attribute name after the dot;</li>
<li><code>expression</code> — the expression automatically compiled from the attribute value;</li>
<li><code>scope</code> — the abstract data context in which to execute the expression (<code>null</code>
if the mold is not inside a custom element&#39;s view).</li>
</ul>
<p>Example:</p>
 <div class="code-pair"> 
<pre><code class="hljs lang-typescript"><span class="hljs-keyword">import</span> {Mold, assign} from <span class="hljs-string">'atril'</span>;

@Mold({attributeName: <span class="hljs-string">'my-mold'</span>})
<span class="hljs-keyword">class</span> Ctrl {
  @assign element: HTMLTemplateElement;
  @assign attribute: Attr;
  @assign hint: <span class="hljs-built_in">string</span>;
  @assign expression: <span class="hljs-built_in">Function</span>;
  @assign scope: <span class="hljs-built_in">any</span>;

  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>() </span>{
    <span class="hljs-comment">// &lt;template my-mold.calc="2 + 2"&gt;&lt;/template&gt;</span>
    <span class="hljs-built_in">console</span>.log(element);
    <span class="hljs-comment">// my-mold.calc="2 + 2"</span>
    <span class="hljs-built_in">console</span>.log(attribute);
    <span class="hljs-comment">// 'calc'</span>
    <span class="hljs-built_in">console</span>.log(hint);
    <span class="hljs-comment">// function that returns 4</span>
    <span class="hljs-built_in">console</span>.log(expression);
    <span class="hljs-comment">// outer viewmodel or null</span>
    <span class="hljs-built_in">console</span>.log(scope);
  }
}
</code></pre>
<pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">my-mold.calc</span>=<span class="hljs-value">"2 + 2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
 </div> 
 <sf-collapse class="info">
  <input id="assign-es5" type="checkbox">
  <label for="assign-es5" class="pad">
    <sf-icon svg-icon.="info-circle" class="inline text-info"></sf-icon>
    Click for ES5 version.
  </label> 
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> Mold = <span class="hljs-built_in">require</span>(<span class="hljs-string">'atril'</span>).Mold;

Mold({attributeName: <span class="hljs-string">'my-mold'</span>})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ctrl</span>(<span class="hljs-params"></span>) </span>{}

  <span class="hljs-comment">// Property names to the left, dependency tokens to the right.</span>
  Ctrl.assign = {
    element: <span class="hljs-string">'element'</span>,
    attribute: <span class="hljs-string">'attribute'</span>,
    hint: <span class="hljs-string">'hint'</span>,
    expression: <span class="hljs-string">'expression'</span>,
    scope: <span class="hljs-string">'scope'</span>
  };

  <span class="hljs-keyword">return</span> Ctrl;
}());
</code></pre>
 </sf-collapse> 
<h3><span>Lifecycle</span><a class="heading-anchor" autolink.="lifecycle"><sf-icon class="inline link"></sf-icon></a></h3>
<p>A mold&#39;s life begins with a <code>constructor</code> call. In addition, it can define two
lifecycle methods: <code>onPhase</code> and <code>onDestroy</code>.</p>
<ul>
<li><code>onPhase</code></li>
</ul>
<p>This is called whenever the library reflows the tree of components and
bindings in response to user activity. For an example, see the
<a href="mold/#basics"><code>markdown-live.*</code></a> implementation above.</p>
<ul>
<li><code>onDestroy</code></li>
</ul>
<p>When the root of this virtual DOM branch is irrevocably removed from the
hierarchy, this method is invoked on all components, attributes, and molds. You
can use this as a chance to free memory or perform other cleanup tasks. Example:</p>
<pre><code class="hljs lang-typescript"><span class="hljs-keyword">class</span> Ctrl {
  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>() </span>{
    createWastefulResource();
  }

  onDestroy() {
    deleteWastefulResource();
  }
}
</code></pre>

      </div>

      <div mark-href.active class="doc-sidenav flex-1" style="min-width: 8em">
        <a href>Overview</a>
<a href="quickstart/">Quickstart</a>
<a href="component/">Component</a>
<a href="attribute/">Attribute</a>
<a href="mold/">Mold</a>
<a href="databinding/">Databinding</a>
<a href="bootstrapping/">Bootstrapping</a>
<a href="if/"><code>if</code></a>
<a href="for/"><code>for</code></a>
<a href="let/"><code>let</code></a>
<a href="on/"><code>on</code></a>
<a href="class/"><code>class</code></a>
<a href="ref/"><code>ref</code></a>
<a href="todo/">demo</a>
<!-- TODO section on component interoperation -->
<!-- TODO separate section on dependency assignment -->
<a href="https://gitter.im/Mitranim/atril?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge" target="_blank">
  <img src="https://badges.gitter.im/Join%20Chat.svg">
</a>

      </div>
    </div>

    <sf-footer>
  <sf-footer-body>
    <div class="flex-1 flex flex-column items-start">
      <span>
        2015
        <a href="http://mitranim.com" target="_blank">Mitranim</a>
        (<a href="https://github.com/Mitranim/atril/blob/master/LICENSE" target="_blank">MIT licensed</a>)
      </span>
    </div>
    <div class="flex-1 flex flex-column items-center">
      <a class="flex items-center" href="https://github.com/Mitranim/atril" target="_blank">
        <sf-icon class="github-blue" style="font-size: 2em"></sf-icon>
        Source at GitHub
      </a>
    </div>
    <div class="flex-1 flex flex-column items-end">
      <sf-icon class="arrow-up pointer fade" onclick="scrollTo(0, 0)"></sf-icon>
    </div>
  </sf-footer-body>
</sf-footer>
  </body>

  <noscript>
    <doc-noscript>
  <doc-noscript-content class="narrow-inverse">
    <h2>Hello! :)</h2>
    <p>This site is a live demo for <a href="https://github.com/Mitranim/atril" target="_blank"><code>atril</code></a>, a JS rendering library. For demo purposes, it's mostly rendered with JavaScript.</p>
    <p>Please enable JavaScript in your browser. Thank you!</p>
  </doc-noscript-content>
</doc-noscript>

  </noscript>
</html>
